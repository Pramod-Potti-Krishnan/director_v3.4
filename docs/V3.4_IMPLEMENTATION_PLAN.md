# Director Agent v3.4 Implementation Plan
## Slide Type Taxonomy & Batch Processing Upgrade

**Parent Document**: `/TAXONOMY_ARCHITECTURE_V3.4_V1.1.md`
**Service**: Director Agent
**Current Version**: v3.3
**Target Version**: v3.4
**Est. Implementation Time**: 2 weeks

---

## Overview

Director v3.4 introduces intelligent slide type classification and batch processing capabilities to work with Text Service v1.1's specialized endpoints.

**Key Changes**:
1. Enhanced strawman stage with AI-powered slide type classification
2. Batch request preparation for parallel processing
3. Updated Stage 6 to use specialized endpoints
4. Fallback logic for graceful degradation

---

## 1. File Changes Required

### 1.1 Modified Files

```
agents/director_agent/v3.3/
├── src/agents/director.py              # MAJOR CHANGES
│   ├── Add: _classify_slide_type()
│   ├── Add: _prepare_batch_request()
│   ├── Add: _generate_slides_batch()
│   ├── Update: CONTENT_GENERATION state handler
│   └── Update: _generate_slide_text() for fallback
│
├── src/utils/text_service_client.py     # MAJOR CHANGES
│   ├── Add: generate_batch() method
│   ├── Add: generate_specialized() method
│   └── Update: _transform_request() for new fields
│
├── src/models/agents.py                 # MINOR CHANGES
│   └── Update: Slide model to include slide_type field
│
├── config/settings.py                   # MINOR CHANGES
│   └── Add: USE_BATCH_PROCESSING, USE_SPECIALIZED_ENDPOINTS flags
│
└── docs/
    ├── V3.4_IMPLEMENTATION_PLAN.md      # NEW
    └── V3.4_CHANGELOG.md                # NEW (after implementation)
```

### 1.2 New Files

```
agents/director_agent/v3.3/
└── src/utils/
    └── slide_type_classifier.py         # NEW: Classification logic
```

---

## 2. Slide Type Taxonomy for Director

### 2.1 Slide Type Enumeration

Create new enum in `src/models/agents.py`:

```python
from enum import Enum

class L29SlideType(str, Enum):
    """L29 (Hero) slide subtypes"""
    TITLE_SLIDE = "title_slide"
    SECTION_DIVIDER = "section_divider"
    CLOSING_SLIDE = "closing_slide"

class L25SlideType(str, Enum):
    """L25 (Content) slide subtypes based on narrative pattern"""
    BILATERAL_COMPARISON = "bilateral_comparison"
    MATRIX_2X2 = "matrix_2x2"
    SEQUENTIAL_3COL = "sequential_3col"
    ASYMMETRIC_8_4 = "asymmetric_8_4"
    HYBRID_1_2X2 = "hybrid_1_2x2"
    SINGLE_COLUMN = "single_column"
    IMPACT_QUOTE = "impact_quote"
    METRICS_GRID = "metrics_grid"
    STYLED_TABLE = "styled_table"
    GRID_3X3 = "grid_3x3"
```

### 2.2 Update Slide Model

```python
class Slide(BaseModel):
    """Individual slide within a presentation"""
    slide_number: int
    slide_id: str
    title: str
    slide_type: str
    narrative: str
    key_points: list[str]
    assets: Optional[Dict[str, Any]] = None
    layout_id: Optional[str] = None  # v3.2: L25 or L29

    # v3.4: NEW - Specific slide type for specialized generation
    slide_type_classification: Optional[str] = None  # One of 13 taxonomy types
```

---

## 3. Implementation: Slide Type Classifier

### 3.1 New Module: `src/utils/slide_type_classifier.py`

```python
"""
Slide Type Classifier for Director v3.4
========================================

AI-powered slide type classification based on content analysis.
Maps slides to one of 13 specialized taxonomy types.
"""

from typing import Optional, List
import re
from src.models.agents import Slide, L29SlideType, L25SlideType
from src.utils.logger import setup_logger

logger = setup_logger(__name__)


class SlideTypeClassifier:
    """
    Classifies slides into specific taxonomy types for specialized generation.
    """

    def __init__(self):
        """Initialize classifier with keyword patterns"""
        self.comparison_keywords = [
            "vs", "versus", "compared to", "before", "after",
            "traditional", "modern", "old", "new", "pros", "cons",
            "advantages", "disadvantages", "challenges", "opportunities"
        ]

        self.matrix_keywords = [
            "swot", "matrix", "framework", "quadrant",
            "eisenhower", "bcg", "ansoff", "strategic"
        ]

        self.sequential_keywords = [
            "step", "phase", "stage", "process", "workflow",
            "first", "second", "third", "then", "next", "finally"
        ]

        self.metrics_keywords = [
            "revenue", "growth", "kpi", "metrics", "performance",
            "$", "%", "increase", "decrease", "roi", "ebitda"
        ]

    def classify(
        self,
        slide: Slide,
        position: str,  # "first" | "middle" | "last"
        layout_id: str   # "L25" | "L29"
    ) -> str:
        """
        Classify slide into specific taxonomy type.

        Args:
            slide: Slide object with content
            position: Slide position in presentation
            layout_id: L25 or L29

        Returns:
            Slide type string (one of 13 types)
        """
        if layout_id == "L29":
            return self._classify_l29(slide, position)
        else:  # L25
            return self._classify_l25(slide)

    def _classify_l29(self, slide: Slide, position: str) -> str:
        """
        Classify L29 hero slides.

        Logic:
        - First slide → title_slide
        - Last slide → closing_slide
        - Middle slide → section_divider (or regular hero)
        """
        if position == "first":
            return L29SlideType.TITLE_SLIDE

        if position == "last":
            # Check for closing indicators
            title_lower = slide.title.lower()
            narrative_lower = slide.narrative.lower()

            closing_indicators = [
                "thank", "questions", "contact", "next steps",
                "call to action", "summary", "conclusion"
            ]

            if any(ind in title_lower or ind in narrative_lower
                   for ind in closing_indicators):
                return L29SlideType.CLOSING_SLIDE

        # Default middle hero: section divider
        return L29SlideType.SECTION_DIVIDER

    def _classify_l25(self, slide: Slide) -> str:
        """
        Classify L25 content slides using heuristics.

        Priority order (most specific to most general):
        1. Quote/Impact (single powerful statement)
        2. Metrics Grid (multiple KPIs)
        3. Matrix 2x2 (strategic framework)
        4. Grid 3x3 (exactly 9 items)
        5. Table (structured data)
        6. Comparison (bilateral)
        7. Sequential (3-step process)
        8. Hybrid (topic + 4 examples)
        9. Asymmetric (thesis + support)
        10. Single Column (default narrative)
        """
        key_points = slide.key_points or []
        narrative = slide.narrative.lower()
        title = slide.title.lower()
        combined_text = f"{title} {narrative} {' '.join(key_points)}".lower()

        # 1. Impact Quote: No key points or single powerful statement
        if len(key_points) == 0 or (len(key_points) == 1 and len(key_points[0]) < 100):
            return L25SlideType.IMPACT_QUOTE

        # 2. Metrics Grid: Multiple items with numbers/percentages
        if len(key_points) >= 3:
            metric_count = sum(1 for kp in key_points
                             if any(c.isdigit() or c in ['$', '%'] for c in kp))
            if metric_count >= 3:
                return L25SlideType.METRICS_GRID

        # 3. Matrix 2x2: Exactly 4 items + matrix keywords
        if len(key_points) == 4:
            if any(keyword in combined_text for keyword in self.matrix_keywords):
                return L25SlideType.MATRIX_2X2

        # 4. Grid 3x3: Exactly 9 items
        if len(key_points) == 9:
            return L25SlideType.GRID_3X3

        # 5. Styled Table: Table-like structure or data comparison
        if self._is_tabular_data(key_points):
            return L25SlideType.STYLED_TABLE

        # 6. Bilateral Comparison: Comparison keywords present
        if any(keyword in combined_text for keyword in self.comparison_keywords):
            return L25SlideType.BILATERAL_COMPARISON

        # 7. Sequential 3-column: 3 items or sequential keywords
        if len(key_points) == 3:
            if any(keyword in combined_text for keyword in self.sequential_keywords):
                return L25SlideType.SEQUENTIAL_3COL

        # 8. Hybrid (1 + 2x2): 4-5 items with hierarchical structure
        if 4 <= len(key_points) <= 5:
            # Check if first point is a "parent" and rest are "children"
            if self._has_parent_child_structure(key_points):
                return L25SlideType.HYBRID_1_2X2

        # 9. Asymmetric 8+4: Long narrative + supporting points
        if len(narrative) > 200 and 2 <= len(key_points) <= 4:
            return L25SlideType.ASYMMETRIC_8_4

        # 10. Default: Single Column
        return L25SlideType.SINGLE_COLUMN

    def _is_tabular_data(self, key_points: List[str]) -> bool:
        """
        Detect if key points represent tabular data.

        Indicators:
        - Consistent colon-separated format (Label: Value)
        - Numeric data across multiple items
        - Row/column keywords
        """
        if len(key_points) < 3:
            return False

        colon_count = sum(1 for kp in key_points if ':' in kp)
        if colon_count >= len(key_points) * 0.7:  # 70%+ have colons
            return True

        return False

    def _has_parent_child_structure(self, key_points: List[str]) -> bool:
        """
        Detect parent-child relationship.

        Heuristic: First point is significantly longer than others
        """
        if len(key_points) < 4:
            return False

        first_length = len(key_points[0])
        avg_rest = sum(len(kp) for kp in key_points[1:]) / (len(key_points) - 1)

        # Parent is 2x+ longer than children
        return first_length > avg_rest * 2
```

---

## 4. Implementation: Director Changes

### 4.1 Update `director.py` - Stage 3 Enhancement

Add classification call after layout selection:

```python
# In GENERATE_STRAWMAN state handler, after layout selection loop:

# v3.4: Classify slide types for specialized generation
for idx, slide in enumerate(strawman.slides):
    position = "first" if idx == 0 else "last" if idx == total_slides - 1 else "middle"

    # Classify slide type
    classifier = SlideTypeClassifier()
    slide_type = classifier.classify(
        slide=slide,
        position=position,
        layout_id=slide.layout_id
    )

    # Store classification
    slide.slide_type_classification = slide_type

    logger.info(
        f"Slide {idx + 1}: {slide.layout_id} → {slide_type}"
    )
```

### 4.2 Update `director.py` - Stage 6 Batch Processing

Replace sequential loop with batch processing:

```python
# In CONTENT_GENERATION state handler:

elif state_context.current_state == "CONTENT_GENERATION":
    logger.info("Starting Stage 6: Content Generation (Batch Processing)")

    strawman_data = state_context.session_data.get("presentation_strawman")
    if not strawman_data:
        raise ValueError("No strawman found in session")

    strawman = PresentationStrawman(**strawman_data)

    # v3.4: Check if batch processing is enabled
    use_batch = get_settings().USE_BATCH_PROCESSING

    if use_batch and len(strawman.slides) > 1:
        # Batch processing path
        logger.info(f"Using batch processing for {len(strawman.slides)} slides")

        # Prepare batch request
        batch_request = self._prepare_batch_request(
            slides=strawman.slides,
            strawman=strawman,
            session_id=session_id
        )

        # Call Text Service batch endpoint
        try:
            batch_results = await self._generate_slides_batch(batch_request)

            # Build enriched slides
            enriched_slides = []
            successful = 0
            failed = 0

            for idx, (slide, result) in enumerate(zip(strawman.slides, batch_results)):
                if result.get("success"):
                    enriched_slides.append(EnrichedSlide(
                        original_slide=slide,
                        slide_id=slide.slide_id,
                        generated_text=GeneratedText(**result)
                    ))
                    successful += 1
                else:
                    logger.error(f"Slide {idx + 1} generation failed: {result.get('error')}")
                    failed += 1

            logger.info(f"Batch complete: {successful} success, {failed} failed")

        except Exception as e:
            logger.error(f"Batch processing failed: {e}")
            logger.warning("Falling back to sequential processing")
            # Fallback to sequential (existing v3.3 logic)
            enriched_slides = await self._generate_slides_sequential(strawman, session_id)

    else:
        # Sequential processing (v3.3 logic)
        logger.info("Using sequential processing")
        enriched_slides = await self._generate_slides_sequential(strawman, session_id)

    # Rest of Stage 6 logic (send to deck builder, etc.)
    # ...
```

### 4.3 New Method: `_prepare_batch_request()`

```python
def _prepare_batch_request(
    self,
    slides: List[Slide],
    strawman: PresentationStrawman,
    session_id: str
) -> Dict[str, Any]:
    """
    Prepare batch request for Text Service v1.1.

    Extracts shared context (sent once, not repeated per slide)
    and builds slide-specific requests.

    Returns:
        Dictionary matching Text Service BatchGenerationRequest schema
    """
    # Extract shared context from strawman
    shared_context = {
        "presentation_title": strawman.main_title,
        "theme": strawman.overall_theme,
        "audience": strawman.target_audience,
        "overall_narrative": strawman.design_suggestions
    }

    # Build slide requests
    slide_requests = []
    for slide in slides:
        # Calculate constraints
        constraints = self._build_constraints_from_schema(slide.layout_id)

        slide_req = {
            "slide_id": slide.slide_id,
            "slide_number": slide.slide_number,
            "layout_id": slide.layout_id,
            "slide_type": slide.slide_type_classification,  # v3.4: NEW
            "title": slide.title,
            "narrative": slide.narrative,
            "key_points": slide.key_points or [],
            "constraints": constraints
        }
        slide_requests.append(slide_req)

    return {
        "session_id": session_id,
        "shared_context": shared_context,
        "slides": slide_requests
    }
```

### 4.4 New Method: `_generate_slides_batch()`

```python
async def _generate_slides_batch(
    self,
    batch_request: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """
    Call Text Service batch endpoint.

    Args:
        batch_request: Batch request dictionary

    Returns:
        List of generation results (one per slide, in order)
    """
    if not self.text_service_enabled:
        raise Exception("Text Service is not enabled")

    return await self.text_client.generate_batch(batch_request)
```

### 4.5 Fallback Method: `_generate_slides_sequential()`

Extract current v3.3 loop logic into this method for fallback:

```python
async def _generate_slides_sequential(
    self,
    strawman: PresentationStrawman,
    session_id: str
) -> List[EnrichedSlide]:
    """
    Fallback to sequential slide generation (v3.3 logic).

    Used when:
    - Batch processing is disabled
    - Batch endpoint fails
    - Single slide presentation
    """
    enriched_slides = []
    successful = 0
    failed = 0

    for idx, slide in enumerate(strawman.slides):
        try:
            logger.info(f"Generating slide {idx + 1}/{len(strawman.slides)}")
            generated_text = await self._generate_slide_text(
                slide,
                strawman,
                session_id,
                idx + 1
            )
            enriched_slides.append(EnrichedSlide(
                original_slide=slide,
                slide_id=slide.slide_id,
                generated_text=generated_text
            ))
            successful += 1
        except Exception as e:
            logger.error(f"Slide {idx + 1} failed: {e}")
            failed += 1

    logger.info(f"Sequential complete: {successful} success, {failed} failed")
    return enriched_slides
```

---

## 5. Enriched Strawman Metadata Architecture (NEW v3.4)

### 5.1 Overview: Richer Content Guidance

**Problem**: Current strawman captures basic slide info (title, narrative, key_points) but lacks **detailed guidance** needed for high-quality content generation.

**Solution**: Enhance Stage 3 (GENERATE_STRAWMAN) to capture enriched metadata that provides:
- Detailed content generation instructions
- Visual emphasis and tone indicators
- Relationship to surrounding slides
- Data type classification

**Why This Matters**: The text service (and future diagram/chart services) need **rich context** to generate appropriate content. Simple key_points aren't enough.

---

### 5.2 Enhanced Slide Model

Update `src/models/agents.py` with new enrichment fields:

```python
class ContentGuidance(BaseModel):
    """
    Detailed guidance for content generators.

    Captured during strawman generation (Stage 3) to provide
    rich context for content generation services (Stage 6).
    """

    # Content Type Classification
    content_type: str = Field(
        default="text_only",
        description="Content type: text_only | diagram | chart | mixed"
    )

    # Visual Complexity & Density
    visual_complexity: str = Field(
        default="medium",
        description="Visual complexity: simple | medium | complex"
    )
    content_density: str = Field(
        default="balanced",
        description="Content density: text_heavy | white_space_heavy | balanced"
    )

    # Tone & Emotion
    tone_indicator: str = Field(
        default="professional",
        description="Slide tone: confident | cautious | urgent | celebratory | neutral | professional"
    )

    # Data Classification
    data_type: str = Field(
        default="qualitative",
        description="Data type: qualitative | quantitative | mixed"
    )

    # Key Point Emphasis
    emphasis_hierarchy: List[int] = Field(
        default_factory=list,
        description="Indices of key_points to emphasize (0-indexed), e.g., [0, 2] emphasizes 1st and 3rd points"
    )

    # Slide Relationship Context
    relationship_to_previous: str = Field(
        default="new_topic",
        description="Relationship: continuation | contrast | supporting_detail | new_topic | conclusion"
    )

    # Detailed Generation Instructions
    generation_instructions: str = Field(
        default="",
        description="Specific instructions for content generator, e.g., 'Focus on numerical impact', 'Use timeline visual'"
    )

    # Visual Pattern Rationale
    pattern_rationale: str = Field(
        default="",
        description="Why this visual pattern was chosen, e.g., 'Metrics require card-based display for impact'"
    )


class Slide(BaseModel):
    """Individual slide within a presentation"""
    slide_number: int
    slide_id: str
    title: str
    slide_type: str
    narrative: str
    key_points: list[str]
    assets: Optional[Dict[str, Any]] = None
    layout_id: Optional[str] = None  # v3.2: L25 or L29

    # v3.4: Slide type classification
    slide_type_classification: Optional[str] = None

    # v3.4: NEW - Enriched content guidance
    content_guidance: Optional[ContentGuidance] = None
```

---

### 5.3 Stage 3 Enhancement: Capture Rich Metadata

Update GENERATE_STRAWMAN state handler in `director.py`:

```python
# In GENERATE_STRAWMAN state handler, after slide type classification:

for idx, slide in enumerate(strawman.slides):
    position = "first" if idx == 0 else "last" if idx == total_slides - 1 else "middle"

    # Existing: Classify slide type
    classifier = SlideTypeClassifier()
    slide_type = classifier.classify(slide, position, slide.layout_id)
    slide.slide_type_classification = slide_type

    # v3.4 NEW: Generate content guidance
    content_guidance = self._generate_content_guidance(
        slide=slide,
        slide_type=slide_type,
        position=position,
        strawman=strawman,
        previous_slide=strawman.slides[idx - 1] if idx > 0 else None
    )
    slide.content_guidance = content_guidance

    logger.info(
        f"Slide {idx + 1}: {slide.layout_id} → {slide_type} "
        f"[tone: {content_guidance.tone_indicator}, "
        f"density: {content_guidance.content_density}]"
    )
```

---

### 5.4 New Method: `_generate_content_guidance()`

```python
def _generate_content_guidance(
    self,
    slide: Slide,
    slide_type: str,
    position: str,
    strawman: PresentationStrawman,
    previous_slide: Optional[Slide]
) -> ContentGuidance:
    """
    Generate rich content guidance for a slide.

    Analyzes slide content and context to provide detailed
    instructions for content generation services.

    Args:
        slide: Slide to analyze
        slide_type: Classified slide type (from SlideTypeClassifier)
        position: Slide position (first/middle/last)
        strawman: Full presentation context
        previous_slide: Previous slide for relationship detection

    Returns:
        ContentGuidance object with rich metadata
    """
    # Determine content type
    content_type = "text_only"  # v3.4: Only text, v3.5 will add diagram/chart

    # Determine visual complexity
    visual_complexity = self._assess_visual_complexity(slide, slide_type)

    # Determine content density
    content_density = self._assess_content_density(slide, slide_type)

    # Determine tone
    tone_indicator = self._detect_tone(slide, strawman, position)

    # Classify data type
    data_type = self._classify_data_type(slide)

    # Determine emphasis hierarchy
    emphasis_hierarchy = self._rank_key_points(slide)

    # Detect relationship to previous slide
    relationship = self._detect_slide_relationship(slide, previous_slide)

    # Generate specific instructions
    instructions = self._build_generation_instructions(
        slide, slide_type, tone_indicator, data_type
    )

    # Build pattern rationale
    rationale = self._build_pattern_rationale(slide, slide_type)

    return ContentGuidance(
        content_type=content_type,
        visual_complexity=visual_complexity,
        content_density=content_density,
        tone_indicator=tone_indicator,
        data_type=data_type,
        emphasis_hierarchy=emphasis_hierarchy,
        relationship_to_previous=relationship,
        generation_instructions=instructions,
        pattern_rationale=rationale
    )

def _assess_visual_complexity(self, slide: Slide, slide_type: str) -> str:
    """Assess visual complexity based on slide type and content"""
    complex_types = ["matrix_2x2", "grid_3x3", "styled_table", "hybrid_1_2x2"]
    simple_types = ["impact_quote", "title_slide", "closing_slide"]

    if slide_type in complex_types:
        return "complex"
    elif slide_type in simple_types:
        return "simple"
    else:
        return "medium"

def _assess_content_density(self, slide: Slide, slide_type: str) -> str:
    """Assess content density preference"""
    text_heavy_types = ["single_column", "asymmetric_8_4"]
    white_space_types = ["impact_quote", "metrics_grid", "title_slide"]

    if slide_type in text_heavy_types:
        return "text_heavy"
    elif slide_type in white_space_types:
        return "white_space_heavy"
    else:
        return "balanced"

def _detect_tone(
    self,
    slide: Slide,
    strawman: PresentationStrawman,
    position: str
) -> str:
    """
    Detect slide tone from content and context.

    Returns: confident | cautious | urgent | celebratory | neutral | professional
    """
    narrative_lower = slide.narrative.lower()
    title_lower = slide.title.lower()
    combined = f"{title_lower} {narrative_lower}"

    # Confident indicators
    confident_words = ["strong", "leading", "dominant", "superior", "excelling"]
    if any(word in combined for word in confident_words):
        return "confident"

    # Urgent indicators
    urgent_words = ["critical", "immediate", "urgent", "now", "crisis", "asap"]
    if any(word in combined for word in urgent_words):
        return "urgent"

    # Celebratory indicators
    celebratory_words = ["success", "achievement", "milestone", "breakthrough", "victory"]
    if any(word in combined for word in celebratory_words):
        return "celebratory"

    # Cautious indicators
    cautious_words = ["risk", "concern", "challenge", "threat", "potential issue"]
    if any(word in combined for word in cautious_words):
        return "cautious"

    # Default: professional
    return "professional"

def _classify_data_type(self, slide: Slide) -> str:
    """
    Classify data type in slide.

    Returns: qualitative | quantitative | mixed
    """
    key_points = slide.key_points or []

    # Count points with numbers
    quantitative_count = sum(
        1 for kp in key_points
        if any(c.isdigit() or c in ['$', '%'] for c in kp)
    )

    if quantitative_count == 0:
        return "qualitative"
    elif quantitative_count == len(key_points):
        return "quantitative"
    else:
        return "mixed"

def _rank_key_points(self, slide: Slide) -> List[int]:
    """
    Rank key points by importance for emphasis.

    Returns list of indices to emphasize (0-indexed).
    Currently uses simple heuristics, could use LLM in future.
    """
    key_points = slide.key_points or []
    if not key_points:
        return []

    emphasized = []

    for idx, kp in enumerate(key_points):
        # Emphasize points with numbers (likely metrics)
        if any(c.isdigit() or c in ['$', '%'] for c in kp):
            emphasized.append(idx)
        # Emphasize first and last points
        elif idx == 0 or idx == len(key_points) - 1:
            emphasized.append(idx)

    # Limit to top 3
    return emphasized[:3]

def _detect_slide_relationship(
    self,
    slide: Slide,
    previous_slide: Optional[Slide]
) -> str:
    """
    Detect relationship to previous slide.

    Returns: continuation | contrast | supporting_detail | new_topic | conclusion
    """
    if not previous_slide:
        return "new_topic"

    # Check for continuation keywords
    continuation_words = ["also", "additionally", "furthermore", "moreover", "and"]
    if any(word in slide.narrative.lower() for word in continuation_words):
        return "continuation"

    # Check for contrast keywords
    contrast_words = ["however", "but", "conversely", "on the other hand", "alternatively"]
    if any(word in slide.narrative.lower() for word in contrast_words):
        return "contrast"

    # Check for supporting detail keywords
    support_words = ["specifically", "for example", "in particular", "detailed"]
    if any(word in slide.narrative.lower() for word in support_words):
        return "supporting_detail"

    # Check if last slide (conclusion)
    conclusion_words = ["conclusion", "summary", "in summary", "therefore", "thus"]
    if any(word in slide.narrative.lower() for word in conclusion_words):
        return "conclusion"

    # Default: new topic
    return "new_topic"

def _build_generation_instructions(
    self,
    slide: Slide,
    slide_type: str,
    tone: str,
    data_type: str
) -> str:
    """
    Build specific instructions for content generator.

    These instructions are passed to the content service to guide generation.
    """
    instructions = []

    # Tone-based instructions
    if tone == "confident":
        instructions.append("Use assertive language and strong action verbs")
    elif tone == "cautious":
        instructions.append("Use measured language and acknowledge risks")
    elif tone == "celebratory":
        instructions.append("Emphasize achievements and positive outcomes")
    elif tone == "urgent":
        instructions.append("Convey immediacy and importance")

    # Data type instructions
    if data_type == "quantitative":
        instructions.append("Emphasize numerical values with large, bold formatting")
    elif data_type == "qualitative":
        instructions.append("Focus on narrative flow and conceptual clarity")
    elif data_type == "mixed":
        instructions.append("Balance numerical data with contextual narrative")

    # Slide type specific instructions
    if slide_type == "metrics_grid":
        instructions.append("Use card-based layout with prominent numbers")
    elif slide_type == "bilateral_comparison":
        instructions.append("Ensure equal visual weight on both sides")
    elif slide_type == "impact_quote":
        instructions.append("Maximize text size and minimize surrounding elements")

    return "; ".join(instructions)

def _build_pattern_rationale(self, slide: Slide, slide_type: str) -> str:
    """
    Explain why this visual pattern was chosen.

    Useful for debugging and future refinement.
    """
    rationales = {
        "metrics_grid": "Multiple KPIs require card-based display for visual impact",
        "bilateral_comparison": "Contrasting concepts benefit from side-by-side layout",
        "matrix_2x2": "Strategic framework requires positional meaning in grid",
        "sequential_3col": "Multi-step process flows naturally left-to-right",
        "impact_quote": "Single powerful statement demands minimalist presentation",
        "styled_table": "Structured data requires tabular format for comparison",
        "single_column": "Dense narrative content needs continuous reading flow",
        "asymmetric_8_4": "Dominant thesis with supporting context benefits from size contrast",
        "hybrid_1_2x2": "Main topic with sub-examples fits parent-child structure",
        "grid_3x3": "Nine-element categorization requires 3x3 matrix",
        "title_slide": "Presentation opener requires bold, centered hero layout",
        "section_divider": "Topic transition needs visual break and clear heading",
        "closing_slide": "Conclusion requires call-to-action and next steps focus"
    }

    return rationales.get(slide_type, "Standard content layout")
```

---

### 5.5 Update Batch Request to Include Guidance

Update `_prepare_batch_request()` to include content guidance:

```python
def _prepare_batch_request(
    self,
    slides: List[Slide],
    strawman: PresentationStrawman,
    session_id: str
) -> Dict[str, Any]:
    """Prepare batch request with enriched content guidance"""

    # ... existing shared_context logic ...

    slide_requests = []
    for slide in slides:
        constraints = self._build_constraints_from_schema(slide.layout_id)

        slide_req = {
            "slide_id": slide.slide_id,
            "slide_number": slide.slide_number,
            "layout_id": slide.layout_id,
            "slide_type": slide.slide_type_classification,
            "title": slide.title,
            "narrative": slide.narrative,
            "key_points": slide.key_points or [],
            "constraints": constraints,

            # v3.4 NEW: Include content guidance
            "content_guidance": slide.content_guidance.dict() if slide.content_guidance else None
        }
        slide_requests.append(slide_req)

    return {
        "session_id": session_id,
        "shared_context": shared_context,
        "slides": slide_requests
    }
```

---

## 6. Service Registry & Availability Management (NEW v3.4)

### 6.1 Overview: Multi-Service Architecture

**Current State**: Director only knows about Text Service.

**v3.4 Goal**: Prepare for multiple content services (text, diagram, chart, image) while maintaining **feature flags** for availability.

**Key Principle**: Director should **check service availability** before routing, and gracefully handle unavailable services.

---

### 6.2 Service Registry Configuration

Create `config/service_registry.py`:

```python
"""
Content Generation Service Registry
=====================================

Manages availability and routing for content generation services.

v3.4: Only text_generation available
v3.5: Add diagram_generation
v3.6: Add chart_generation, image_generation
"""

from enum import Enum
from typing import Dict, List, Optional
from pydantic import BaseModel, Field


class ServiceType(str, Enum):
    """Available content generation service types"""
    TEXT_GENERATION = "text_generation"
    DIAGRAM_GENERATION = "diagram_generation"  # v3.5
    CHART_GENERATION = "chart_generation"      # v3.6
    IMAGE_GENERATION = "image_generation"      # v3.6


class ServiceConfig(BaseModel):
    """Configuration for a content generation service"""
    service_type: ServiceType
    enabled: bool = Field(default=False, description="Is this service available?")
    base_url: Optional[str] = Field(None, description="Service API base URL")
    timeout: int = Field(60, description="Request timeout in seconds")
    fallback_enabled: bool = Field(True, description="Allow fallback if service fails")


class LayoutServiceMapping(BaseModel):
    """Maps layouts to their content generation service"""
    layout_id: str
    service_type: ServiceType
    enabled: bool = Field(default=False, description="Is this layout available?")
    description: str = Field("", description="Layout description")


# Service Registry Configuration
SERVICE_REGISTRY: Dict[ServiceType, ServiceConfig] = {
    # v3.4: Text Generation (ENABLED)
    ServiceType.TEXT_GENERATION: ServiceConfig(
        service_type=ServiceType.TEXT_GENERATION,
        enabled=True,  # Available in v3.4
        base_url="http://localhost:8002",  # Override from env
        timeout=120
    ),

    # v3.5: Diagram Generation (DISABLED)
    ServiceType.DIAGRAM_GENERATION: ServiceConfig(
        service_type=ServiceType.DIAGRAM_GENERATION,
        enabled=False,  # Not yet available
        base_url=None,
        timeout=90
    ),

    # v3.6: Chart Generation (DISABLED)
    ServiceType.CHART_GENERATION: ServiceConfig(
        service_type=ServiceType.CHART_GENERATION,
        enabled=False,  # Not yet available
        base_url=None,
        timeout=60
    ),

    # v3.6: Image Generation (DISABLED)
    ServiceType.IMAGE_GENERATION: ServiceConfig(
        service_type=ServiceType.IMAGE_GENERATION,
        enabled=False,  # Not yet available
        base_url=None,
        timeout=90
    )
}


# Layout-to-Service Mapping
LAYOUT_MAPPINGS: List[LayoutServiceMapping] = [
    # v3.4: Text Layouts (ENABLED)
    LayoutServiceMapping(
        layout_id="L25",
        service_type=ServiceType.TEXT_GENERATION,
        enabled=True,
        description="Main Content Shell - Text generation"
    ),
    LayoutServiceMapping(
        layout_id="L29",
        service_type=ServiceType.TEXT_GENERATION,
        enabled=True,
        description="Full-Bleed Hero - Text generation"
    ),

    # v3.5: Diagram Layouts (DISABLED)
    LayoutServiceMapping(
        layout_id="L30",
        service_type=ServiceType.DIAGRAM_GENERATION,
        enabled=False,  # Future
        description="Process Flow Diagram"
    ),
    LayoutServiceMapping(
        layout_id="L31",
        service_type=ServiceType.DIAGRAM_GENERATION,
        enabled=False,  # Future
        description="Organization Chart"
    ),
    LayoutServiceMapping(
        layout_id="L32",
        service_type=ServiceType.DIAGRAM_GENERATION,
        enabled=False,  # Future
        description="System Architecture Diagram"
    ),

    # v3.6: Chart Layouts (DISABLED)
    LayoutServiceMapping(
        layout_id="L40",
        service_type=ServiceType.CHART_GENERATION,
        enabled=False,  # Future
        description="Bar/Column Chart"
    ),
    LayoutServiceMapping(
        layout_id="L41",
        service_type=ServiceType.CHART_GENERATION,
        enabled=False,  # Future
        description="Line/Area Chart"
    ),
    LayoutServiceMapping(
        layout_id="L42",
        service_type=ServiceType.CHART_GENERATION,
        enabled=False,  # Future
        description="Pie/Donut Chart"
    ),
]


def get_service_for_layout(layout_id: str) -> Optional[ServiceConfig]:
    """
    Get the content generation service for a layout.

    Args:
        layout_id: Layout identifier (e.g., "L25", "L30")

    Returns:
        ServiceConfig if layout is enabled, None otherwise
    """
    # Find layout mapping
    mapping = next(
        (m for m in LAYOUT_MAPPINGS if m.layout_id == layout_id),
        None
    )

    if not mapping or not mapping.enabled:
        return None

    # Get service config
    service_config = SERVICE_REGISTRY.get(mapping.service_type)

    if not service_config or not service_config.enabled:
        return None

    return service_config


def get_available_layouts() -> List[str]:
    """
    Get list of currently available layout IDs.

    Returns:
        List of enabled layout IDs (e.g., ["L25", "L29"])
    """
    return [
        mapping.layout_id
        for mapping in LAYOUT_MAPPINGS
        if mapping.enabled
    ]


def is_service_available(service_type: ServiceType) -> bool:
    """
    Check if a service is currently available.

    Args:
        service_type: Service type to check

    Returns:
        True if service is enabled
    """
    config = SERVICE_REGISTRY.get(service_type)
    return config.enabled if config else False
```

---

### 6.3 Update Settings for Service Registry

Update `config/settings.py`:

```python
class Settings(BaseSettings):
    """Application settings"""

    # ... existing settings ...

    # v3.4: Service Availability Flags
    TEXT_SERVICE_ENABLED: bool = Field(True, env="TEXT_SERVICE_ENABLED")
    DIAGRAM_SERVICE_ENABLED: bool = Field(False, env="DIAGRAM_SERVICE_ENABLED")  # v3.5
    CHART_SERVICE_ENABLED: bool = Field(False, env="CHART_SERVICE_ENABLED")      # v3.6
    IMAGE_SERVICE_ENABLED: bool = Field(False, env="IMAGE_SERVICE_ENABLED")      # v3.6

    # Service URLs (override defaults from service_registry.py)
    TEXT_SERVICE_URL: str = Field("http://localhost:8002", env="TEXT_SERVICE_URL")
    DIAGRAM_SERVICE_URL: Optional[str] = Field(None, env="DIAGRAM_SERVICE_URL")  # v3.5
    CHART_SERVICE_URL: Optional[str] = Field(None, env="CHART_SERVICE_URL")      # v3.6
```

Update `.env.example`:

```bash
# v3.4: Content Generation Services
TEXT_SERVICE_ENABLED=true            # Text generation (L25, L29)
DIAGRAM_SERVICE_ENABLED=false        # Diagram generation (L30-L32) - v3.5
CHART_SERVICE_ENABLED=false          # Chart generation (L40-L42) - v3.6
IMAGE_SERVICE_ENABLED=false          # Image generation - v3.6

TEXT_SERVICE_URL=http://localhost:8002
# DIAGRAM_SERVICE_URL=http://localhost:8003  # Uncomment in v3.5
# CHART_SERVICE_URL=http://localhost:8004     # Uncomment in v3.6
```

---

### 6.4 Runtime Service Availability Check

Update `director.py` initialization:

```python
def __init__(self):
    """Initialize Director with service registry"""

    # ... existing initialization ...

    # v3.4: Initialize service registry from settings
    from config.service_registry import SERVICE_REGISTRY, ServiceType
    from config.settings import get_settings

    settings = get_settings()

    # Update service registry from settings
    if settings.TEXT_SERVICE_ENABLED:
        SERVICE_REGISTRY[ServiceType.TEXT_GENERATION].enabled = True
        SERVICE_REGISTRY[ServiceType.TEXT_GENERATION].base_url = settings.TEXT_SERVICE_URL

    if settings.DIAGRAM_SERVICE_ENABLED:
        SERVICE_REGISTRY[ServiceType.DIAGRAM_GENERATION].enabled = True
        SERVICE_REGISTRY[ServiceType.DIAGRAM_GENERATION].base_url = settings.DIAGRAM_SERVICE_URL

    # Log available services
    available_services = [
        s.value for s, c in SERVICE_REGISTRY.items() if c.enabled
    ]
    logger.info(f"Available content services: {available_services}")

    # Log available layouts
    from config.service_registry import get_available_layouts
    available_layouts = get_available_layouts()
    logger.info(f"Available layouts: {available_layouts}")
```

---

## 7. Future-Proof Multi-Service Architecture (NEW v3.4)

### 7.1 Overview: Preparing for Diagram/Chart Services

**Current**: Director → Text Service (L25, L29 only)

**Future**: Director → **Service Router** → Text/Diagram/Chart/Image Services

**Design Goal**: Create abstract interface now so adding new services in v3.5+ requires minimal changes.

---

### 7.2 Abstract Content Generator Interface

Create `src/utils/content_generator_interface.py`:

```python
"""
Abstract Content Generator Interface
=====================================

Unified interface for all content generation services.

v3.4: Implemented by TextServiceClient
v3.5: Will be implemented by DiagramServiceClient
v3.6: Will be implemented by ChartServiceClient, ImageServiceClient
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List
from src.models.agents import Slide
from src.models.content import GeneratedContent


class ContentGeneratorInterface(ABC):
    """
    Abstract base class for content generation services.

    All content services (text, diagram, chart, image) must implement this interface.
    """

    @abstractmethod
    async def generate(
        self,
        slide: Slide,
        shared_context: Dict[str, Any]
    ) -> GeneratedContent:
        """
        Generate content for a single slide.

        Args:
            slide: Slide with layout_id, slide_type_classification, content_guidance
            shared_context: Shared presentation context (theme, audience, etc.)

        Returns:
            GeneratedContent with content field and metadata
        """
        pass

    @abstractmethod
    async def generate_batch(
        self,
        slides: List[Slide],
        shared_context: Dict[str, Any]
    ) -> List[GeneratedContent]:
        """
        Generate content for multiple slides in parallel.

        Args:
            slides: List of slides to generate
            shared_context: Shared presentation context

        Returns:
            List of GeneratedContent (one per slide, in order)
        """
        pass

    @abstractmethod
    def is_available(self) -> bool:
        """
        Check if this service is currently available.

        Returns:
            True if service is reachable and healthy
        """
        pass

    @abstractmethod
    def get_supported_layouts(self) -> List[str]:
        """
        Get list of layout IDs this service supports.

        Returns:
            List of layout IDs (e.g., ["L25", "L29"])
        """
        pass
```

---

### 7.3 Update TextServiceClient to Implement Interface

Update `src/utils/text_service_client.py`:

```python
from src.utils.content_generator_interface import ContentGeneratorInterface
from src.models.content import GeneratedContent


class TextServiceClient(ContentGeneratorInterface):
    """
    Text & Table Builder service client.

    v3.4: Implements ContentGeneratorInterface for L25 and L29 layouts.
    """

    def __init__(self, base_url: str = None):
        """Initialize text service client"""
        self.base_url = base_url or "http://localhost:8002"
        self.api_base = f"{self.base_url}/api/v1"
        self.timeout = 120
        self.supported_layouts = ["L25", "L29"]

        logger.info(f"TextServiceClient initialized: {self.base_url}")

    def is_available(self) -> bool:
        """Check if text service is available"""
        try:
            response = requests.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200
        except:
            return False

    def get_supported_layouts(self) -> List[str]:
        """Get supported layouts"""
        return self.supported_layouts

    # Existing generate() and generate_batch() methods already match interface
    # ... (keep existing implementation)
```

---

### 7.4 Service Router & Orchestration Layer

Create `src/utils/content_service_router.py`:

```python
"""
Content Service Router
=======================

Routes slides to appropriate content generation service based on layout.

v3.4: Routes to TextServiceClient for L25/L29
v3.5: Will route to DiagramServiceClient for L30-L32
v3.6: Will route to ChartServiceClient for L40-L42
"""

from typing import Dict, Any, List, Optional
from src.models.agents import Slide
from src.models.content import GeneratedContent
from src.utils.content_generator_interface import ContentGeneratorInterface
from src.utils.text_service_client import TextServiceClient
from src.utils.logger import setup_logger
from config.service_registry import get_service_for_layout, ServiceType

logger = setup_logger(__name__)


class ContentServiceRouter:
    """
    Routes slide generation requests to appropriate service.

    Handles service availability checking and fallback logic.
    """

    def __init__(self):
        """Initialize router with available services"""
        self.services: Dict[ServiceType, ContentGeneratorInterface] = {}

        # v3.4: Initialize text service
        from config.settings import get_settings
        settings = get_settings()

        if settings.TEXT_SERVICE_ENABLED:
            self.services[ServiceType.TEXT_GENERATION] = TextServiceClient(
                base_url=settings.TEXT_SERVICE_URL
            )
            logger.info("Registered TextServiceClient")

        # v3.5: Will add DiagramServiceClient
        # if settings.DIAGRAM_SERVICE_ENABLED:
        #     self.services[ServiceType.DIAGRAM_GENERATION] = DiagramServiceClient(...)

        # v3.6: Will add ChartServiceClient, ImageServiceClient

    def get_service_for_slide(
        self,
        slide: Slide
    ) -> Optional[ContentGeneratorInterface]:
        """
        Get appropriate content service for a slide.

        Args:
            slide: Slide with layout_id

        Returns:
            ContentGeneratorInterface if available, None otherwise
        """
        service_config = get_service_for_layout(slide.layout_id)

        if not service_config:
            logger.warning(f"No service available for layout {slide.layout_id}")
            return None

        service = self.services.get(service_config.service_type)

        if not service:
            logger.warning(f"Service {service_config.service_type} not initialized")
            return None

        # Check service availability
        if not service.is_available():
            logger.warning(f"Service {service_config.service_type} is not available")
            return None

        return service

    async def route_single_slide(
        self,
        slide: Slide,
        shared_context: Dict[str, Any]
    ) -> GeneratedContent:
        """
        Route single slide to appropriate service.

        Args:
            slide: Slide to generate
            shared_context: Shared presentation context

        Returns:
            GeneratedContent

        Raises:
            Exception: If no service available or generation fails
        """
        service = self.get_service_for_slide(slide)

        if not service:
            raise Exception(f"No available service for layout {slide.layout_id}")

        logger.info(
            f"Routing slide {slide.slide_id} ({slide.layout_id}) "
            f"to {service.__class__.__name__}"
        )

        return await service.generate(slide, shared_context)

    async def route_batch(
        self,
        slides: List[Slide],
        shared_context: Dict[str, Any]
    ) -> List[GeneratedContent]:
        """
        Route batch of slides to appropriate services.

        Groups slides by service, processes each group in parallel,
        then reassembles results in original order.

        Args:
            slides: List of slides to generate
            shared_context: Shared presentation context

        Returns:
            List of GeneratedContent (one per slide, in order)
        """
        import asyncio

        # Group slides by service
        service_groups: Dict[ContentGeneratorInterface, List[Slide]] = {}
        slide_to_service: Dict[str, ContentGeneratorInterface] = {}

        for slide in slides:
            service = self.get_service_for_slide(slide)
            if not service:
                logger.warning(f"Skipping slide {slide.slide_id} (no service)")
                continue

            if service not in service_groups:
                service_groups[service] = []

            service_groups[service].append(slide)
            slide_to_service[slide.slide_id] = service

        # Generate content for each service group in parallel
        tasks = []
        for service, group_slides in service_groups.items():
            logger.info(
                f"Batching {len(group_slides)} slides to {service.__class__.__name__}"
            )
            task = service.generate_batch(group_slides, shared_context)
            tasks.append(task)

        # Wait for all services to complete
        results_by_service = await asyncio.gather(*tasks, return_exceptions=True)

        # Flatten results back to original order
        results_map: Dict[str, GeneratedContent] = {}
        for result_group in results_by_service:
            if isinstance(result_group, Exception):
                logger.error(f"Service batch failed: {result_group}")
                continue

            for result in result_group:
                results_map[result.slide_id] = result

        # Reconstruct in original order
        final_results = []
        for slide in slides:
            result = results_map.get(slide.slide_id)
            if result:
                final_results.append(result)
            else:
                # Create error result
                final_results.append(GeneratedContent(
                    slide_id=slide.slide_id,
                    success=False,
                    error="Service unavailable or generation failed"
                ))

        return final_results
```

---

### 7.5 Update Director to Use Service Router

Update Stage 6 in `director.py`:

```python
# In CONTENT_GENERATION state handler:

from src.utils.content_service_router import ContentServiceRouter

elif state_context.current_state == "CONTENT_GENERATION":
    logger.info("Starting Stage 6: Content Generation (Service Router)")

    strawman_data = state_context.session_data.get("presentation_strawman")
    if not strawman_data:
        raise ValueError("No strawman found in session")

    strawman = PresentationStrawman(**strawman_data)

    # v3.4: Initialize service router
    router = ContentServiceRouter()

    # Prepare shared context
    shared_context = {
        "presentation_title": strawman.main_title,
        "theme": strawman.overall_theme,
        "audience": strawman.target_audience,
        "overall_narrative": strawman.design_suggestions
    }

    # Route slides to appropriate services (batch if possible)
    use_batch = get_settings().USE_BATCH_PROCESSING

    if use_batch and len(strawman.slides) > 1:
        logger.info("Using batch routing for multiple slides")
        try:
            results = await router.route_batch(
                slides=strawman.slides,
                shared_context=shared_context
            )

            # Build enriched slides
            enriched_slides = []
            for slide, result in zip(strawman.slides, results):
                if result.success:
                    enriched_slides.append(EnrichedSlide(
                        original_slide=slide,
                        slide_id=slide.slide_id,
                        generated_content=result
                    ))
                else:
                    logger.error(f"Slide {slide.slide_id} failed: {result.error}")

        except Exception as e:
            logger.error(f"Batch routing failed: {e}")
            logger.warning("Falling back to sequential")
            # Fallback to sequential
            enriched_slides = await self._generate_slides_sequential_router(
                strawman, shared_context, router
            )
    else:
        # Sequential routing
        logger.info("Using sequential routing")
        enriched_slides = await self._generate_slides_sequential_router(
            strawman, shared_context, router
        )

    # Rest of Stage 6 logic...
```

Add new fallback method:

```python
async def _generate_slides_sequential_router(
    self,
    strawman: PresentationStrawman,
    shared_context: Dict[str, Any],
    router: ContentServiceRouter
) -> List[EnrichedSlide]:
    """
    Sequential generation using service router.

    Used as fallback when batch fails or for single slides.
    """
    enriched_slides = []

    for idx, slide in enumerate(strawman.slides):
        try:
            logger.info(f"Routing slide {idx + 1}/{len(strawman.slides)}")
            result = await router.route_single_slide(slide, shared_context)

            enriched_slides.append(EnrichedSlide(
                original_slide=slide,
                slide_id=slide.slide_id,
                generated_content=result
            ))
        except Exception as e:
            logger.error(f"Slide {idx + 1} failed: {e}")

    return enriched_slides
```

---

### 7.6 Future Service Integration (v3.5+)

**Adding Diagram Service in v3.5** will require:

1. Create `DiagramServiceClient` implementing `ContentGeneratorInterface`
2. Enable in `service_registry.py`: `ServiceType.DIAGRAM_GENERATION.enabled = True`
3. Add layouts L30-L32 to `LAYOUT_MAPPINGS` with `enabled=True`
4. Update `ContentServiceRouter.__init__()` to register DiagramServiceClient
5. Set `DIAGRAM_SERVICE_ENABLED=true` in .env

**No changes required to Director logic** - the service router handles everything!

---

## 8. Implementation: Text Service Client Updates

### 5.1 Update `src/utils/text_service_client.py`

Add batch processing method:

```python
async def generate_batch(
    self,
    batch_request: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """
    Generate content for multiple slides in parallel.

    Args:
        batch_request: Batch request matching BatchGenerationRequest schema

    Returns:
        List of generation results (one per slide, in order)

    Raises:
        Exception: On API errors or timeouts
    """
    endpoint = f"{self.api_base}/generate/batch"

    loop = asyncio.get_event_loop()
    try:
        response = await loop.run_in_executor(
            None,
            self._sync_post,
            endpoint,
            batch_request,
            120  # Longer timeout for batch
        )
    except Exception as e:
        logger.error(f"Batch generation failed: {str(e)}")
        raise

    return response.get("results", [])

def _sync_post(
    self,
    endpoint: str,
    request: Dict,
    timeout: int
) -> Dict:
    """
    Synchronous POST request.

    Args:
        endpoint: Full API endpoint URL
        request: Request body dictionary
        timeout: Timeout in seconds

    Returns:
        Response JSON

    Raises:
        Exception: On HTTP errors or timeout
    """
    try:
        logger.info(f"Calling {endpoint}")
        response = requests.post(
            endpoint,
            json=request,
            timeout=timeout
        )
        response.raise_for_status()
        logger.info(f"Response: {response.status_code}")
        return response.json()

    except requests.Timeout:
        logger.error(f"Request timeout after {timeout}s")
        raise Exception(f"Request timeout after {timeout}s")
    except requests.HTTPError as e:
        logger.error(f"HTTP error: {e.response.status_code}")
        raise Exception(f"HTTP error: {e.response.status_code}")
    except Exception as e:
        logger.error(f"Request failed: {str(e)}")
        raise
```

---

## 6. Configuration Updates

### 6.1 Update `config/settings.py`

Add new feature flags:

```python
class Settings(BaseSettings):
    """Application settings with environment variable support"""

    # ... existing settings ...

    # v3.4: Batch processing and specialized endpoints
    USE_BATCH_PROCESSING: bool = Field(True, env="USE_BATCH_PROCESSING")
    USE_SPECIALIZED_ENDPOINTS: bool = Field(True, env="USE_SPECIALIZED_ENDPOINTS")
    BATCH_TIMEOUT: int = Field(120, env="BATCH_TIMEOUT")  # seconds
```

### 6.2 Update `.env.example`

```bash
# v3.4: Batch Processing Configuration
USE_BATCH_PROCESSING=true  # Enable parallel slide generation
USE_SPECIALIZED_ENDPOINTS=true  # Use taxonomy-based specialized endpoints
BATCH_TIMEOUT=120  # Batch request timeout in seconds
```

---

## 7. Testing Requirements

### 7.1 Unit Tests

Create `tests/test_slide_type_classifier.py`:

```python
import pytest
from src.utils.slide_type_classifier import SlideTypeClassifier
from src.models.agents import Slide

def test_classify_l29_title_slide():
    """Test that first slide is classified as title_slide"""
    classifier = SlideTypeClassifier()
    slide = Slide(
        slide_number=1,
        slide_id="s1",
        title="Welcome",
        slide_type="title_slide",
        narrative="Opening slide",
        key_points=[]
    )

    result = classifier.classify(slide, "first", "L29")
    assert result == "title_slide"

def test_classify_l25_metrics_grid():
    """Test metrics detection"""
    classifier = SlideTypeClassifier()
    slide = Slide(
        slide_number=2,
        slide_id="s2",
        title="Q4 Performance",
        slide_type="content_heavy",
        narrative="Key metrics",
        key_points=[
            "Revenue: $127M (+32% YoY)",
            "EBITDA: 32.3%",
            "New customers: 2,400"
        ]
    )

    result = classifier.classify(slide, "middle", "L25")
    assert result == "metrics_grid"

# Add 20+ more test cases covering all 13 types
```

Create `tests/test_batch_processing.py`:

```python
import pytest
from src.agents.director import DirectorAgent

@pytest.mark.asyncio
async def test_prepare_batch_request():
    """Test batch request preparation"""
    director = DirectorAgent()
    # Create mock strawman with 3 slides
    # Call _prepare_batch_request()
    # Assert structure matches expected schema
    pass

@pytest.mark.asyncio
async def test_batch_generation():
    """Test batch generation with mock Text Service"""
    # Mock Text Service batch endpoint
    # Call _generate_slides_batch()
    # Assert all slides processed
    pass
```

### 7.2 Integration Tests

Create `tests/test_v34_integration.py`:

```python
@pytest.mark.asyncio
async def test_end_to_end_batch_generation():
    """
    Full workflow test:
    1. Generate strawman (Stage 3)
    2. Classify slide types
    3. Batch generate content (Stage 6)
    4. Verify all slides have content
    """
    pass

@pytest.mark.asyncio
async def test_fallback_to_sequential():
    """
    Test that batch failure falls back to sequential
    """
    pass
```

### 7.3 Performance Tests

Create `tests/test_v34_performance.py`:

```python
import time

@pytest.mark.asyncio
async def test_batch_vs_sequential_speed():
    """
    Compare batch vs sequential processing time
    """
    # Generate 10-slide presentation
    # Time batch processing
    # Time sequential processing
    # Assert batch is faster
    pass
```

---

## 8. Deployment Checklist

### 8.1 Pre-Deployment

- [ ] All unit tests passing
- [ ] Integration tests passing
- [ ] Performance benchmarks meet targets
- [ ] Code review completed
- [ ] Documentation updated
- [ ] Environment variables configured

### 8.2 Deployment Steps

1. **Deploy to staging**:
   ```bash
   git checkout -b feature/v3.4-taxonomy
   # Make all changes
   git commit -m "feat: Director v3.4 - Slide Type Taxonomy & Batch Processing"
   git push origin feature/v3.4-taxonomy
   # Create PR and merge to staging
   ```

2. **Staging validation**:
   - Test with 5 different presentation types
   - Verify slide type classification accuracy
   - Measure batch processing performance
   - Test fallback logic

3. **Production rollout**:
   - Enable feature flag for 10% of traffic
   - Monitor error rates and performance
   - Gradually increase to 50%, then 100%

### 8.3 Rollback Plan

If critical issues detected:

```bash
# Disable batch processing
export USE_BATCH_PROCESSING=false

# Or full rollback to v3.3
git revert <v3.4-commit-hash>
git push origin main
```

---

## 9. Success Criteria

### 9.1 Functional Requirements

- [ ] All 13 slide types correctly classified (90%+ accuracy)
- [ ] Batch processing completes successfully
- [ ] Fallback to sequential works when batch fails
- [ ] No regression in existing functionality

### 9.2 Performance Requirements

- [ ] Batch processing 60-70% faster than sequential
- [ ] Classification adds <1s per slide
- [ ] Error rate <1%

### 9.3 Quality Requirements

- [ ] Presentations show 8-10 different patterns (vs 2-3 currently)
- [ ] Pattern matches content appropriately
- [ ] User feedback positive

---

## 10. Open Questions & Decisions

1. **Manual Override**: Should users be able to manually override slide type classification?
   - **Decision**: Phase 2 feature, not in v3.4

2. **Confidence Thresholds**: Should we add confidence scores to classification?
   - **Decision**: Track internally, don't expose in v3.4

3. **Caching**: Should we cache batch requests?
   - **Decision**: No caching in v3.4, evaluate in v3.5

---

## 11. Timeline

| Week | Tasks |
|------|-------|
| Week 1 | Implement SlideTypeClassifier, update Slide model, write unit tests |
| Week 2 | Implement batch processing, update TextServiceClient, integration tests |
| Week 3 | Staging deployment, performance testing, bug fixes |
| Week 4 | Production rollout, monitoring, documentation finalization |

---

**Next Steps**:
1. Review this plan with team
2. Create GitHub issues for each major task
3. Begin Week 1 implementation
4. Parallel: Text Service v1.1 implementation (see separate doc)
